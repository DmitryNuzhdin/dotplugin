//Copyright 2013 GoGraphviz Authors
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

//This bnf has been derived from http://www.graphviz.org/content/dot-language
//The rules have been copied and are shown in the comments, with their derived bnf rules below.

// ### [ Tokens ] ##############################################################

// The keywords node, edge, graph, digraph, subgraph, and strict are case-
// independent.
{
  parserClass="org.plugin.dot.parser.DotParser"
  parserUtilClass="org.plugin.dot.DotPSITreeUtil"

  extends="org.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Dot"
  psiImplClassSuffix="Impl"
  psiPackage="org.plugin.dot.psi"
  psiImplPackage="org.plugin.dot.psi.impl"

  elementTypeHolderClass="org.plugin.dot.psi.DotTypes"
  elementTypeClass="org.plugin.dot.psi.DotElementType"
  tokenTypeClass="org.plugin.dot.psi.DotTokenType"

  psiImplUtilClass="org.plugin.dot.psi.impl.DotPsiImplUtil"
}

node
	::= 'n' 'o' 'd' 'e'
	| 'N' 'o' 'd' 'e'
	| 'N' 'O' 'D' 'E'
;

edge
	::= 'e' 'd' 'g' 'e'
	| 'E' 'd' 'g' 'e'
	| 'E' 'D' 'G' 'E'
;

// TODO::= Rename graphx to graph once gocc#20 is fixed [1].
//
// [1]::= https::=//github.com/goccmack/gocc/issues/20

graphx
	::= 'g' 'r' 'a' 'p' 'h'
	| 'G' 'r' 'a' 'p' 'h'
	| 'G' 'R' 'A' 'P' 'H'
;

digraph
	::= 'd' 'i' 'g' 'r' 'a' 'p' 'h'
	| 'D' 'i' 'g' 'r' 'a' 'p' 'h'
	| 'd' 'i' 'G' 'r' 'a' 'p' 'h'
	| 'D' 'i' 'G' 'r' 'a' 'p' 'h'
	| 'D' 'I' 'G' 'R' 'A' 'P' 'H'
;

subgraph
	::= 's' 'u' 'b' 'g' 'r' 'a' 'p' 'h'
	| 'S' 'u' 'b' 'g' 'r' 'a' 'p' 'h'
	| 's' 'u' 'b' 'G' 'r' 'a' 'p' 'h'
	| 'S' 'u' 'b' 'G' 'r' 'a' 'p' 'h'
	| 'S' 'U' 'B' 'G' 'R' 'A' 'P' 'H'
;

strict
	::= 's' 't' 'r' 'i' 'c' 't'
	| 'S' 't' 'r' 'i' 'c' 't'
	| 'S' 'T' 'R' 'I' 'C' 'T'
;

// An arbitrary ASCII character except null (0x00), double quote (0x22) and
// backslash (0x5C).
ascii_char ::= char
//	// skip null (0x00)
//	::= '\x01' - '\x21'
//	// skip double quote (0x22)
//	| '\x23' - '\x5B'
//	// skip backslash (0x5C)
//	| '\x5D' - '\x7F'
//;

ascii_letter
	::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
	| "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
	|"U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
	| "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
	| "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
;

ascii_digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";

unicode_char
	::= ascii_char
	| unicode_byte
;

unicode_byte ::= char
// TODO:
//	::= '\u0080' - '\uFFFC'
//	// skip invalid code point (\uFFFD)
//	| '\uFFFE' - '\U0010FFFF'
;

letter        ::= ascii_letter | unicode_byte | '_' ;
decimal_digit ::= ascii_digit ;
decimals      ::= decimal_digit { decimal_digit } ;

// An ID is one of the following:
//
//    1) Any string of alphabetic ([a-zA-Z\200-\377]) characters, underscores
//       ('_') or digits ([0-9]), not beginning with a digit;
//
//    2) a numeral [-]?(.[0-9]+ | [0-9]+(.[0-9]*)? );
//
//    3) any double-quoted string ("...") possibly containing escaped quotes
//       (\");
//
//    4) an HTML string (<...>).

id
	::= letter { letter | decimal_digit }
	| int_lit
	| string_lit
	| html_lit
;

int_lit
	::= [ '-' ] '.' decimals
	| [ '-' ] decimals [ '.' { decimal_digit } ]
;

// In quoted strings in DOT, the only escaped character is double-quote (").
// That is, in quoted strings, the dyad \" is converted to "; all other
// characters are left unchanged. In particular, \\ remains \\.

// As another aid for readability, dot allows double-quoted strings to span
// multiple physical lines using the standard C convention of a backslash
// immediately preceding a newline character.

// In addition, double-quoted strings can be concatenated using a '+' operator.

escaped_char ::= '\\' ( unicode_char | '"' | '\\' ) ;
char         ::= unicode_char | escaped_char ;
string_lit   ::= '"' { char } '"' ;

// An arbitrary HTML character except null (0x00), left angle bracket (0x3C) and
// right angle bracket (0x3E).
html_char ::= char
// TODO:
//	// skip null (0x00)
//	::= '\x01' - '\x3B'
//	// skip left angle bracket (0x3C)
//	| '\x3D'
//	// skip right angle bracket (0x3E)
//	| '\x3F' - '\xFF'
//;

html_chars ::= { html_char } ;
html_tag   ::= '<' html_chars '>' ;
html_lit   ::= '<' { html_chars | html_tag } '>' ;
// The language supports C++-style comments: /* */ and //. In addition, a line
// beginning with a '#' character is considered a line output from a C
// preprocessor (e.g., # 34 to indicate line 34 ) and discarded.

line_comment ::= comment_character {char| whitespace} EOL;
EOL ::= "\n"
comment_character ::= "//" | "#"

block_comment ::= '/' '*' { char | whitespace | '*' } '*' '/' ;
comment       ::= line_comment | block_comment ;

whitespace ::= ' ' | '\t' | '\r' | '\n' ;

// ### [ Syntax ] ##############################################################

//graph	:	[ strict ] (graph | digraph) [ ID ] '{' stmt_list '}'
DotGraph
	::= graphx "{" "}"
	| strict graphx "{" "}"
	| graphx Id "{" "}"
	| strict graphx Id "{" "}"
	| graphx "{" StmtList "}"
	| graphx Id "{" StmtList "}"
	| strict graphx "{" StmtList "}"
	| strict graphx Id "{" StmtList "}"
	| digraph "{" "}"
	| strict digraph "{" "}"
	| digraph Id "{" "}"
	| strict digraph Id "{" "}"
	| digraph "{" StmtList "}"
	| digraph Id "{" StmtList "}"
	| strict digraph "{" StmtList "}"
	| strict digraph Id "{" StmtList "}"
	;

//stmt_list	:	[ stmt [ ';' ] [ stmt_list ] ]
StmtList
	::=  Stmt1
	|  StmtList Stmt1
	;

Stmt1
	::=  Stmt
	|  Stmt ";"
	;

//stmt	:	node_stmt | edge_stmt | attr_stmt | (ID '=' ID) | subgraph
Stmt
	::= Id "=" Id
	| NodeStmt
	| EdgeStmt
	| AttrStmt
	| SubGraphStmt
	;

//attr_stmt	:	(graph | node | edge) attr_list
AttrStmt
	::= graphx AttrList
	| node AttrList
	| edge AttrList
	;

//attr_list	:	'[' [ a_list ] ']' [ attr_list ]
AttrList
	::= "[" "]"
	| "[" AList "]"
	| AttrList "[" "]"
	| AttrList "[" AList "]"
	;

//a_list	:	ID [ '=' ID ] [ ',' ] [ a_list ]
AList
	::= Attr
	| AList Attr
	| AList "," Attr
	;

//An a_list clause of the form ID is equivalent to ID=true.
Attr
	::= Id
	| Id "=" Id
	;

//edge_stmt	:	(node_id | subgraph) edgeRHS [ attr_list ]
EdgeStmt
	::= NodeId EdgeRHS
	| NodeId EdgeRHS AttrList
	| SubGraphStmt EdgeRHS
	| SubGraphStmt EdgeRHS AttrList
	;

//edgeRHS	:	edgeop (node_id | subgraph) [ edgeRHS ]
EdgeRHS
	::= EdgeOp NodeId
	| EdgeOp SubGraphStmt
	| EdgeRHS EdgeOp NodeId
	| EdgeRHS EdgeOp SubGraphStmt
	;

//node_stmt	:	node_id [ attr_list ]
NodeStmt
	::= NodeId
	| NodeId AttrList
	;

//node_id	:	ID [ port ]
NodeId
	::= Id
	| Id Port
	;

//compass_pt	:	(n | ne | e | se | s | sw | w | nw | c | _)
//Note also that the allowed compass point values are not keywords,
//so these strings can be used elsewhere as ordinary identifiers and,
//conversely, the parser will actually accept any identifier.
//port	:	':' ID [ ':' compass_pt ]
//		|	':' compass_pt
Port
	::= ":" Id
	| ":" Id ":" Id
	;

//subgraph	:	[ subgraph [ ID ] ] '{' stmt_list '}'
SubGraphStmt
	::= "{" StmtList "}"
	| subgraph "{" StmtList "}"
	| subgraph Id "{" StmtList "}"
	;

//An edgeop is -> in directed graphs and -- in undirected graphs.
EdgeOp
	::= "->"
	| "--"
	;

//		An ID is one of the following:
//		Any string of alphabetic ([a-zA-Z'200-'377]) characters, underscores ('_') or digits ([0-9]), not beginning with a digit; //CHECK 200-377
//		a numeral [-]?(.[0-9]+ | [0-9]+(.[0-9]*)? );
//		any double-quoted string ("...") possibly containing escaped quotes ('")1; //TODO
//		an HTML string (<...>).
//		An ID is just a string; the lack of quote characters in the first two forms is just for simplicity.
//		There is no semantic difference between abc_2 and "abc_2", or between 2.34 and "2.34".
//		Obviously, to use a keyword as an ID, it must be quoted. Note that, in HTML strings, angle brackets must occur in matched pairs, and unescaped newlines are allowed.
//		In addition, the content must be legal XML, so that the special XML escape sequences for ", &, <, and > may be necessary in order to embed these characters in attribute values or raw text.
//		Both quoted strings and HTML strings are scanned as a unit, so any embedded comments will be treated as part of the strings.
Id
	::= id
	;

//The language supports C++-style comments: /* */ and //.
//In addition, a line beginning with a '#' character is considered a line output from a C preprocessor (e.g., # 34 to indicate line 34 ) and discarded.

//TODO (if dot file is not parsable, it might be because of these points)

//Semicolons aid readability but are not required except in the rare case that a named subgraph with no body immediately preceeds an anonymous subgraph,
//since the precedence rules cause this sequence to be parsed as a subgraph with a heading and a body. Also, any amount of whitespace may be inserted between terminals.

//TODO
//As another aid for readability, dot allows single logical lines to span multiple physical lines using the standard C convention of a backslash immediately preceding a newline character.
//In addition, double-quoted strings can be concatenated using a '+' operator. As HTML strings can contain newline characters, they do not support the concatenation operator.

//TODO
//Note there are still 3 sections on the webpage which have not been included (Subgraphs and Clusters, Lexical and Semantic Notes, and Character Encodings)
